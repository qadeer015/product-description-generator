class DescriptionGenerator {
    constructor() {
        this.isInitialized = false;
        this.chromeAvailable = false;
        this.shortDesc = null;
        this.longDesc = null;
        this.settings = this.getSettings();
        this.init();
        this.STATIC_PROMPT = `
You are an expert marketplace product copywriter specializing in medical and surgical products for online sales platforms.

Rules:

* Write SEO-friendly content optimized for medical and healthcare-related searches
* Use simple, clear, and professional English suitable for end users and healthcare buyers
* Ensure plagiarism-free and original content
* Accurately represent the product features, benefits, and real use cases
* Write from the end-user perspective, focusing on usability, safety, and reliability
* Use {{productName}} instead of the actual product name
* Naturally include relevant and easy-to-understand keywords such as medical equipment, surgical instruments, healthcare supplies, hospital use, clinical use, home care, durable, safe, sterile, professional quality, and online medical store where applicable
* Avoid exaggerated or misleading claims and comply with medical product standards

Generate:

1. Short Description (40‚Äì60 words)

   * Brief overview of the product
   * Key benefit and primary use
   * Include 1 to 2 high-impact SEO keywords

2. Long Description (120‚Äì150 words)

   * Detailed explanation of product purpose, features, and benefits
   * Suitable applications such as hospital, clinic, or home healthcare use
   * Highlight quality, safety, and ease of use
   * Include relevant SEO keywords naturally for better search visibility

Output format:
Short Description:
<text>

Long Description:
<text>
`;
    }

    async init() {
        if (this.isInitialized) return;

        // Check Chrome API availability
        await this.checkChromeAvailability();

        // Wait for page to load
        await this.waitForPageReady();

        // Inject UI
        this.injectUI();
        this.isInitialized = true;

        // Check if auto-generate is enabled
        await this.checkAutoGenerate();
    }

    async checkChromeAvailability() {
        try {
            if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.sendMessage) {
                this.chromeAvailable = true;
            } else {
                this.chromeAvailable = false;
            }
        } catch (error) {
            console.error('Error checking Chrome availability:', error);
            this.chromeAvailable = false;
        }
    }

    async checkAutoGenerate() {
        try {
            const settings = await this.settings;
            if (settings.autoGenerateDescriptions) {
                // Delay slightly to ensure UI is ready
                setTimeout(() => {
                    this.generateDescription();
                }, 1500);
            }
        } catch (error) {
            console.error('Error checking auto-generate setting:', error);
        }
    }

    async waitForPageReady() {
        return new Promise(resolve => {
            if (document.readyState === 'complete') {
                setTimeout(resolve, 1000);
            } else {
                window.addEventListener('load', () => {
                    setTimeout(resolve, 1000);
                });
            }
        });
    }

    async getSettings() {
        return new Promise((resolve) => {
            try {
                if (!this.chromeAvailable) {
                    const saved = localStorage.getItem('product_descripton_generator_settings');
                    resolve(saved ? JSON.parse(saved) : {
                        apiKeys: [],
                        currentApiKeyIndex: 0,
                        apiEndPoint: 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent'
                    });
                    return;
                }

                const timeout = setTimeout(() => {
                    console.warn('Timeout getting settings from background, retrying...');
                    // Retry once
                    chrome.runtime.sendMessage(
                        { type: 'GET_SETTINGS' },
                        (retryResponse) => {
                            if (chrome.runtime.lastError || !retryResponse?.apiKeys) {
                                console.warn('Retry failed, using localStorage');
                                const saved = localStorage.getItem('product_descripton_generator_settings');
                                resolve(saved ? JSON.parse(saved) : {
                                    apiKeys: [],
                                    currentApiKeyIndex: 0,
                                    apiEndPoint: 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent'
                                });
                            } else {
                                resolve({
                                    apiKeys: retryResponse.apiKeys || [],
                                    currentApiKeyIndex: retryResponse.currentApiKeyIndex || 0,
                                    apiEndPoint: retryResponse.apiEndPoint || 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent'
                                });
                            }
                        }
                    );
                }, 2000);

                chrome.runtime.sendMessage(
                    { type: 'GET_SETTINGS' },
                    (response) => {
                        clearTimeout(timeout);
                        if (chrome.runtime.lastError) {
                            console.warn('Error getting settings:', chrome.runtime.lastError.message);
                            const saved = localStorage.getItem('product_descripton_generator_settings');
                            resolve(saved ? JSON.parse(saved) : {
                                apiKeys: [],
                                currentApiKeyIndex: 0,
                                apiEndPoint: 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent'
                            });
                        } else if (!response || !response.apiKeys) {
                            // Response received but settings not properly loaded
                            console.warn('Settings response incomplete, using localStorage');
                            const saved = localStorage.getItem('product_descripton_generator_settings');
                            resolve(saved ? JSON.parse(saved) : {
                                apiKeys: [],
                                currentApiKeyIndex: 0,
                                apiEndPoint: 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent'
                            });
                        } else {
                            // Ensure all new settings have default values
                            const settings = response;
                            console.log('Settings loaded successfully:', settings);
                            resolve({
                                apiKeys: settings.apiKeys || [],
                                currentApiKeyIndex: settings.currentApiKeyIndex || 0,
                                apiEndPoint: settings.apiEndPoint || 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent',
                                autoGenerateDescriptions: settings.autoGenerateDescriptions || false,
                                autoSaveProduct: settings.autoSaveProduct || false
                            });
                        }
                    }
                );
            } catch (error) {
                console.error('Error in getSettings:', error);
                const saved = localStorage.getItem('product_descripton_generator_settings');
                resolve(saved ? JSON.parse(saved) : {
                    apiKeys: [],
                    currentApiKeyIndex: 0,
                    apiEndPoint: 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent'
                });
            }
        });
    }

    injectUI() {
        if (document.getElementById('product-descripton-generator-ui')) return;

        const floatingBtnContainer = document.createElement("div");
        floatingBtnContainer.classList.add("floating-btn-container");
        const floatingBtn = document.createElement("button");
        const iconImg = document.createElement("img");
        iconImg.src = chrome.runtime.getURL("src/icons/icon_48.png");
        iconImg.alt = "Product Description Generator";
        floatingBtn.appendChild(iconImg);
        floatingBtn.classList.add("floating-btn", "hide");
        floatingBtnContainer.appendChild(floatingBtn);
        document.body.appendChild(floatingBtnContainer);

        const container = document.createElement('div');
        container.id = 'product-descripton-generator-ui';
        container.innerHTML = `
            <div class="pdg-container">
                <div class="pdg-content-wrapper">
                    <div class="pdg-content" id="pdg-content">
                        <button class="pdgui-btn primary" data-action="gen-desc">
                            ‚ú® Generate Description
                        </button>

                        <button class="pdgui-btn primary" data-action="copy-prompt">
                            üìù Copy prompt
                        </button>

                        <button class="pdgui-btn secondary" data-action="open-options">
                            ‚öôÔ∏è Settings
                        </button>
                    </div>
                    <button class="pdg-close">√ó</button>
                </div>
                <div class="pdg-status" id="pdg-status">Ready</div>
            </div>
        `;

        // Add styles
        this.injectStyles();
        document.body.appendChild(container);
        this.attachEventListeners();
    }

    injectStyles() {
        // Same styles as content_main.js
        const style = document.createElement('style');
        style.textContent = `
            #product-descripton-generator-ui {
                min-width: 250px;
                position: fixed;
                bottom: 20px;
                right: calc(50% - 175px);
                z-index: 10000;
                font-family: 'Segoe UI', Arial, sans-serif;
            }

            .pdg-container {
                background: rgb(89,69,118);
                backdrop-filter: blur(10px);
                border-radius: 12px;
                padding: 10px 15px 5px;
                min-width: 250px;
                color: white;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
                animation: slideUp 0.3s ease;
            }

            .floating-btn-container{
                position: fixed;
                bottom: 40px;
                left: 50%;
                transform: translateX(-50%);
                text-align: center;
                z-index: 9999;
            }

            .floating-btn{
                background-color: transparent;
                border: none;
                outline: none;
                cursor: pointer;
            }

            .floating-btn img {
                width: 48px;
                height: 48px;
                cursor: pointer;
                object-fit: contain;
            }

            .show{
                display: block !important;
            }

            .hide{
                display: none !important;
            }

            @keyframes slideUp {
                from { transform: translateY(100px); opacity: 0; }
                to { transform: translateY(0); opacity: 1; }
            }

            .pdg-close {
                background: red;
                border: none;
                outline:none;
                color: white;
                font-size: 24px;
                cursor: pointer;
                padding: 0;
                width: 24px;
                height: 24px;
                display: flex;
                align-items: center;
                justify-content: center;
                border-radius: 50%;
                position: absolute;
                top: -8px;
                right: -8px;
            }

            .pdg-close:hover {
                background: rgba(255, 255, 255, 0.1);
                color: black;
            }

            .pdg-content-wrapper {
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .pdg-content {
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 18px;
            }

            .pdgui-btn {
                padding: 5px 10px;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                font-weight: 600;
                font-size: 14px;
                transition: all 0.2s;
            }

            .pdgui-btn:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            }

            .pdgui-btn.primary {
                background: #10b981;
                color: white;
            }

            .pdg-status {
                margin-top: 10px;
                padding-top: 5px;
                border-top: 1px solid rgba(255, 255, 255, 0.1);
                font-size: 12px;
                opacity: 0.8;
                text-align: center;
            }
            
            .pdgui-btn.primary {
                background: #10b981;
                color: white;
            }
            
            .pdgui-btn.secondary {
                background: #8b5cf6;
                color: white;
            }
        `;
        document.head.appendChild(style);
    }

    attachEventListeners() {
        const container = document.getElementById('product-descripton-generator-ui');
        const floatingBtn = document.querySelector(".floating-btn");

        // Close button
        container.querySelector('.pdg-close').addEventListener('click', () => {
            container.style.display = 'none';
            floatingBtn.classList.remove('hide');
            floatingBtn.classList.add('show');
        });

        floatingBtn.addEventListener('click', (e) => {
            e.preventDefault();
            container.style.display = 'block';
            floatingBtn.classList.remove('show');
            floatingBtn.classList.add('hide');
        })

        // Action buttons
        container.querySelectorAll('.pdgui-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const action = e.target.dataset.action;
                this.handleAction(action);
            });
        });
    }

    async handleAction(action) {
        this.updateStatus('Processing...');

        switch (action) {
            case 'gen-desc':
                await this.generateDescription();
                break;
            case 'copy-prompt':
                await this.copyPromptWithProductName();
                break;
            case 'open-options':
                if (this.chromeAvailable) {
                    chrome.runtime.sendMessage({ type: 'OPEN_OPTIONS' });
                    this.updateStatus('Ready');
                }
                break;
            default:
                this.updateStatus('Ready');
        }
    }

    updateStatus(message) {
        const statusElement = document.getElementById('pdg-status');
        if (statusElement) {
            statusElement.textContent = message;
        }
    }

    async copyPromptWithProductName() {
        try {
            // Get product name from the form field
            const productNameElement = document.querySelector("#product_name");
            const productName = productNameElement ? productNameElement.value.trim() : "";

            // Create the prompt with product name
            let promptWithProductName = this.STATIC_PROMPT;

            // Add product name to the prompt if it exists
            if (productName) {
                promptWithProductName += `\n\nProduct name: ${productName}`;
            } else {
                promptWithProductName += `\n\nProduct name: [Enter Product Name Here]`;
            }

            // Copy to clipboard
            await navigator.clipboard.writeText(promptWithProductName);

            // Update status with product name info
            if (productName) {
                this.updateStatus(`Prompt copied with product: "${productName}"`);
            } else {
                this.updateStatus('Prompt copied (no product name found)');
            }

            setTimeout(() => {
                this.updateStatus('Ready');
            }, 3000);

        } catch (error) {
            console.error('Error copying prompt:', error);
            this.updateStatus('‚ùå Error copying prompt');
        }
    }

    async sendMessage(message) {
        return new Promise((resolve, reject) => {
            try {
                if (!this.chromeAvailable || !chrome?.runtime?.sendMessage) {
                    reject(new Error("Chrome API not available"));
                    return;
                }

                const timeout = setTimeout(() => {
                    reject(new Error("Message timeout"));
                }, 10000);

                chrome.runtime.sendMessage(message, (response) => {
                    clearTimeout(timeout);

                    if (chrome.runtime.lastError) {
                        reject(new Error(chrome.runtime.lastError.message));
                    } else {
                        resolve(response);
                    }
                });
            } catch (error) {
                reject(error);
            }
        });
    }

    async generateDescription() {

        // Get form elements
        const productNameElement = document.querySelector("#product_name");
        const shortDescElement = document.querySelector("#product_short_description");
        const longDescElement = document.querySelector("#product_description");

        if (!productNameElement || !shortDescElement || !longDescElement) {
            this.updateStatus("Error: Could not find form fields");
            console.error("Form fields not found");
            return;
        }

        const productName = productNameElement.value.trim();

        if (!productName) {
            this.updateStatus("Error: Product name is empty");
            alert("Please enter a product name");
            return;
        }

        this.updateStatus("Generating descriptions...");
        shortDescElement.value = "Generating...";
        longDescElement.value = "Generating...";

        try {
            // Get settings from Chrome storage
            let response;
            try {
                response = await this.sendMessage({ type: 'GET_SETTINGS' });
            } catch (error) {
                console.error("Failed to get settings:", error);
                this.updateStatus("‚ùå Error: Cannot connect to extension");
                shortDescElement.value = "Error: Extension communication failed";
                return;
            }
            console.log("Settings received:", response);
            const { apiKeys = [], currentApiKeyIndex = 0, apiEndPoint } = response || {};

            if (!apiKeys || apiKeys.length === 0) {
                throw new Error("No API Keys configured. Please configure settings.");
            }

            const prompt = `${this.STATIC_PROMPT}\nProduct name: ${productName}`;

            // Try current API key, if fails due to quota, rotate to next
            let lastError = null;
            let attemptsCount = 0;
            const maxAttempts = apiKeys.length;
            let localCurrentIndex = currentApiKeyIndex;

            while (attemptsCount < maxAttempts) {
                try {
                    const currentKey = apiKeys[localCurrentIndex];

                    if (!currentKey) {
                        throw new Error("Invalid API key");
                    }

                    const apiResponse = await fetch(
                        `${apiEndPoint}?key=${currentKey}`,
                        {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json"
                            },
                            body: JSON.stringify({
                                contents: [
                                    {
                                        role: "user",
                                        parts: [{ text: prompt }]
                                    }
                                ]
                            })
                        }
                    );

                    const data = await apiResponse.json();

                    // Check for quota exceeded error
                    if (data.error?.message?.includes('quota') || data.error?.message?.includes('Quota')) {
                        lastError = data.error?.message || "API quota exceeded";

                        // Try next API key
                        if (apiKeys.length > 1 && attemptsCount < maxAttempts - 1) {
                            attemptsCount++;

                            // Request rotation from background script
                            try {
                                await this.sendMessage({ type: 'ROTATE_API_KEY' });

                                // Refresh settings to get new index
                                const newSettings = await this.sendMessage({ type: 'GET_SETTINGS' });
                                localCurrentIndex = newSettings?.currentApiKeyIndex || 0;
                            } catch (error) {
                                console.warn("Failed to rotate API key:", error);
                                // Fallback to local rotation
                                localCurrentIndex = (localCurrentIndex + 1) % apiKeys.length;
                            }

                            this.updateStatus(`Quota exceeded, trying next API key...`);
                            continue;
                        }
                    }

                    if (!data.candidates?.length) {
                        throw new Error(data.error?.message || "No text generated");
                    }

                    const text = data.candidates[0].content.parts[0].text;

                    // Parse short and long descriptions from response
                    const shortMatch = text.match(/Short Description:\s*([\s\S]*?)(?:Long Description:|$)/i);
                    const longMatch = text.match(/Long Description:\s*([\s\S]*?)$/i);

                    const shortDesc = shortMatch ? shortMatch[1].trim() : "Short description not found";
                    const longDesc = longMatch ? longMatch[1].trim() : "Long description not found";

                    // Auto-fill the form fields
                    shortDescElement.value = shortDesc;
                    longDescElement.value = longDesc;

                    this.updateStatus("Descriptions generated successfully");

                    // Check if auto-save is enabled
                    const settings = await this.settings;
                    if (settings.autoSaveProduct) {
                        this.autoSaveProduct();
                    }

                    return;

                } catch (error) {
                    lastError = error;
                    attemptsCount++;

                    if (attemptsCount < maxAttempts) {
                        // Try next API key
                        try {
                            await this.sendMessage({ type: 'ROTATE_API_KEY' });

                            const newSettings = await this.sendMessage({ type: 'GET_SETTINGS' });
                            localCurrentIndex = newSettings?.currentApiKeyIndex || 0;
                        } catch (rotateError) {
                            console.warn("Failed to rotate API key:", rotateError);
                            // Fallback to local rotation
                            localCurrentIndex = (localCurrentIndex + 1) % apiKeys.length;
                        }

                        this.updateStatus(`API Error, trying next key...`);
                        continue;
                    }
                }
            }

            // All API keys failed
            throw lastError || new Error("All API keys failed");

        } catch (error) {
            console.error("Generation error:", error);
            shortDescElement.value = "Error: " + error.message;
            longDescElement.value = "";
            this.updateStatus("‚ùå Error: " + error.message);
        }
    }

    autoSaveProduct() {
        try {
            const saveButton = document.getElementById('js-form-btn');
            if (saveButton) {
                this.updateStatus("Auto-saving product...");
                saveButton.click();
            } else {
                console.warn('Save Product button not found');
            }
        } catch (error) {
            console.error('Error auto-saving product:', error);
        }
    }

}

// Initialize the description generator
const descriptionGenerator = new DescriptionGenerator();

// Listen for messages from popup
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
    if (request.type === 'GENERATE_DESCRIPTION') {
        descriptionGenerator.generateDescription().then(() => {
            sendResponse({ success: true });
        }).catch((error) => {
            sendResponse({ success: false, error: error.message });
        });
        return true; // Indicate that we'll send response asynchronously
    }
});
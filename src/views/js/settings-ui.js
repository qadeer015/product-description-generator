import Settings from '../../scripts/settings.js';

// Settings UI Handler
class SettingsUI {
    constructor() {
        this.settingsManager = new Settings();
        this.init();
    }

    async init() {
        await this.settingsManager.initialize();
        this.loadCurrentSettings();
        this.attachEventListeners();
    }

    loadCurrentSettings() {
        const settings = this.settingsManager.getAll();
        document.getElementById('apiEndPoint').value = settings.apiEndPoint || '';
        document.getElementById('autoGenerateDescriptions').checked = settings.autoGenerateDescriptions || false;
        document.getElementById('autoSaveProduct').checked = settings.autoSaveProduct || false;
        this.renderApiKeyFields(settings.apiKeys || [], settings.currentApiKeyIndex || 0);
    }

    renderApiKeyFields(apiKeys, currentIndex) {
        const container = document.getElementById('apiKeysContainer');
        container.innerHTML = '';

        if (apiKeys.length === 0) {
            container.innerHTML = '<p class="no-keys-message">No API keys added yet. Click "Add API Key" to get started.</p>';
            return;
        }

        apiKeys.forEach((apiKey, index) => {
            const fieldContainer = document.createElement('div');
            fieldContainer.className = 'api-key-field-wrapper';
            if (index === currentIndex) {
                fieldContainer.classList.add('active');
            }

            const keyField = document.createElement('input');
            keyField.type = 'password';
            keyField.className = 'api-key-input';
            keyField.value = apiKey;
            keyField.disabled = true;
            keyField.placeholder = `API Key ${index + 1}`;

            const badgeLabel = document.createElement('span');
            badgeLabel.className = 'key-badge';
            badgeLabel.textContent = index === currentIndex ? 'ACTIVE' : `Key ${index + 1}`;

            const toggleShowBtn = document.createElement('button');
            toggleShowBtn.type = 'button';
            toggleShowBtn.className = 'btn-show-key';
            toggleShowBtn.textContent = 'Show';
            toggleShowBtn.addEventListener('click', (e) => {
                e.preventDefault();
                this.toggleShowKey(keyField, toggleShowBtn);
            });

            const copyBtn = document.createElement('button');
            copyBtn.type = 'button';
            copyBtn.className = 'btn-copy-key';
            copyBtn.textContent = 'Copy';
            copyBtn.addEventListener('click', (e) => {
                e.preventDefault();
                this.copyToClipboard(apiKey, copyBtn);
            });

            const deleteBtn = document.createElement('button');
            deleteBtn.type = 'button';
            deleteBtn.className = 'btn-delete-key';
            deleteBtn.textContent = 'Delete';
            deleteBtn.addEventListener('click', (e) => {
                e.preventDefault();
                this.deleteApiKey(index);
            });

            const buttonGroup = document.createElement('div');
            buttonGroup.className = 'api-key-button-group';
            buttonGroup.appendChild(toggleShowBtn);
            buttonGroup.appendChild(copyBtn);
            buttonGroup.appendChild(deleteBtn);

            fieldContainer.appendChild(badgeLabel);
            fieldContainer.appendChild(keyField);
            fieldContainer.appendChild(buttonGroup);
            container.appendChild(fieldContainer);
        });
    }

    toggleShowKey(input, button) {
        if (input.type === 'password') {
            input.type = 'text';
            button.textContent = 'Hide';
        } else {
            input.type = 'password';
            button.textContent = 'Show';
        }
    }

    copyToClipboard(text, button) {
        navigator.clipboard.writeText(text).then(() => {
            const originalText = button.textContent;
            button.textContent = 'Copied!';
            setTimeout(() => {
                button.textContent = originalText;
            }, 2000);
        }).catch(err => {
            console.error('Failed to copy:', err);
            this.showMessage('Failed to copy API key', 'error');
        });
    }

    deleteApiKey(index) {
        if (confirm(`Are you sure you want to delete API Key ${index + 1}?`)) {
            this.settingsManager.removeApiKey(index).then(() => {
                const settings = this.settingsManager.getAll();
                this.renderApiKeyFields(settings.apiKeys || [], settings.currentApiKeyIndex || 0);
                this.showMessage('API key deleted successfully', 'success');
            });
        }
    }

    attachEventListeners() {
        const form = document.getElementById('settingsForm');
        const resetBtn = document.getElementById('resetBtn');
        const addKeyBtn = document.getElementById('addKeyBtn');
        const uploadKeysBtn = document.getElementById('uploadKeysBtn');
        const exportKeysBtn = document.getElementById('exportKeysBtn');
        const fileInput = document.getElementById('keysFileInput');

        form.addEventListener('submit', (e) => this.handleSave(e));
        resetBtn.addEventListener('click', () => this.handleReset());
        addKeyBtn.addEventListener('click', (e) => {
            e.preventDefault();
            this.handleAddApiKey();
        });

        uploadKeysBtn.addEventListener('click', (e) => {
            e.preventDefault();
            fileInput.click();
        });

        exportKeysBtn.addEventListener('click', (e) => {
            e.preventDefault();
            this.handleExportKeys();
        });

        fileInput.addEventListener('change', (e) => this.handleFileUpload(e));

        // Listen for changes in other tabs
        this.settingsManager.addListener((settings) => {
            this.loadCurrentSettings();
            this.showMessage('Settings updated in another tab', 'info');
        });
    }



    async handleFileUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        // Check file type
        if (!file.name.toLowerCase().endsWith('.txt')) {
            this.showMessage('Please upload a .txt file', 'error');
            event.target.value = '';
            return;
        }

        // Check file size (max 10KB)
        if (file.size > 10 * 1024) {
            this.showMessage('File is too large. Maximum size is 10KB', 'error');
            event.target.value = '';
            return;
        }

        try {
            const text = await file.text();
            const keys = this.parseKeysFromFile(text);

            if (keys.length === 0) {
                this.showMessage('No valid API keys found in the file', 'error');
                event.target.value = '';
                return;
            }

            // Show import statistics
            this.showImportStatistics(keys, file.name);

            // Clear the file input
            event.target.value = '';

        } catch (error) {
            console.error('Error reading file:', error);
            this.showMessage('Error reading file: ' + error.message, 'error');
            event.target.value = '';
        }
    }

    parseKeysFromFile(text) {
        const lines = text.split('\n');
        const keys = [];
        const stats = {
            totalLines: lines.length,
            emptyLines: 0,
            duplicateKeys: 0,
            invalidKeys: 0,
            validKeys: 0
        };

        const existingKeys = this.settingsManager.getApiKeys();
        const seenKeys = new Set(existingKeys);

        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();

            if (line === '') {
                stats.emptyLines++;
                continue;
            }

            // Basic validation - API keys usually have a specific pattern
            // Gemini API keys start with "AIza" and are about 39 characters
            if (line.length < 30 || line.length > 100) {
                stats.invalidKeys++;
                continue;
            }

            // Check for duplicates
            if (seenKeys.has(line)) {
                stats.duplicateKeys++;
                continue;
            }

            // Valid key
            keys.push(line);
            seenKeys.add(line);
            stats.validKeys++;
        }

        this.lastImportStats = stats;
        return keys;
    }

    showImportStatistics(keys, fileName) {
        const stats = this.lastImportStats;
        const container = document.getElementById('apiKeysContainer');

        // Create stats display
        const statsDiv = document.createElement('div');
        statsDiv.className = 'key-import-stats success';
        statsDiv.innerHTML = `
            <strong>File: ${fileName}</strong>
            <ul class="key-stats-list">
                <li>Total lines: ${stats.totalLines}</li>
                <li>Empty lines: ${stats.emptyLines}</li>
                <li>Valid keys found: ${stats.validKeys}</li>
                <li>Invalid keys skipped: ${stats.invalidKeys}</li>
                <li>Duplicate keys skipped: ${stats.duplicateKeys}</li>
            </ul>
            <p style="margin-bottom: 8px; margin-top: 4px;"><strong>Found ${keys.length} new API ${keys.length === 1 ? 'key' : 'keys'} to add.</strong></p>
            <div class="import-actions">
                <button id="confirmImportBtn" class="btn-add-key">Add ${keys.length} ${keys.length === 1 ? 'key' : 'keys'}</button>
                <button id="cancelImportBtn" class="btn-cancel">Cancel</button>
            </div>
        `;

        // Insert before the buttons
        const buttonsContainer = document.querySelector('.api-key-buttons');
        container.appendChild(statsDiv);

        // Add event listeners for confirm/cancel
        document.getElementById('confirmImportBtn').addEventListener('click', () => {
            this.confirmImportKeys(keys);
            statsDiv.remove();
        });

        document.getElementById('cancelImportBtn').addEventListener('click', () => {
            statsDiv.remove();
            this.showMessage('Import cancelled', 'info');
        });
    }

    async confirmImportKeys(keys) {
        try {
            let addedCount = 0;
            const existingKeys = this.settingsManager.getApiKeys();

            for (const key of keys) {
                // Skip duplicates (just in case)
                if (existingKeys.includes(key)) {
                    continue;
                }

                // Add the key
                await this.settingsManager.addApiKey(key);
                addedCount++;
            }

            // Refresh the display
            const settings = this.settingsManager.getAll();
            this.renderApiKeyFields(settings.apiKeys || [], settings.currentApiKeyIndex || 0);

            if (addedCount > 0) {
                this.showMessage(`✅ Successfully added ${addedCount} new API keys`, 'success');
            } else {
                this.showMessage('No new keys were added (all were duplicates)', 'info');
            }

        } catch (error) {
            console.error('Error importing keys:', error);
            this.showMessage(`❌ Error importing keys: ${error.message}`, 'error');
        }
    }

    async handleAddApiKey() {
        const apiKey = prompt('Enter the API key:');
        if (!apiKey || !apiKey.trim()) {
            this.showMessage('API key cannot be empty', 'error');
            return;
        }

        const trimmedKey = apiKey.trim();
        const existingKeys = this.settingsManager.getApiKeys();

        if (existingKeys.includes(trimmedKey)) {
            this.showMessage('This API key already exists', 'error');
            return;
        }

        try {
            await this.settingsManager.addApiKey(trimmedKey);
            const settings = this.settingsManager.getAll();
            this.renderApiKeyFields(settings.apiKeys || [], settings.currentApiKeyIndex || 0);
            this.showMessage('API key added successfully', 'success');
        } catch (error) {
            this.showMessage(`Error adding API key: ${error.message}`, 'error');
        }
    }

    handleExportKeys() {
        const apiKeys = this.settingsManager.getApiKeys();

        if (apiKeys.length === 0) {
            this.showMessage('No API keys to export', 'error');
            return;
        }

        // Show export confirmation with warning
        this.showExportConfirmation(apiKeys);
    }

    showExportConfirmation(apiKeys) {
        const container = document.getElementById('apiKeysContainer');

        // Remove any existing confirmation
        const existingConfirmation = container.querySelector('.export-confirmation');
        if (existingConfirmation) {
            existingConfirmation.remove();
        }

        // Create confirmation display
        const confirmationDiv = document.createElement('div');
        confirmationDiv.className = 'export-confirmation';
        confirmationDiv.innerHTML = `
            <p><strong>Export API Keys</strong></p>
            <p>You are about to export ${apiKeys.length} API key(s) to a text file.</p>
            <p class="export-warning">⚠️ Warning: API keys are sensitive information. Keep the downloaded file secure!</p>
            <div class="export-confirmation-buttons">
                <button id="confirmExportBtn" class="btn-add-key">Download ${apiKeys.length} ${apiKeys.length === 1 ? 'key' : 'keys'}</button>
                <button id="cancelExportBtn" class="btn-cancel">Cancel</button>
            </div>
        `;

        // Insert before the buttons
        const buttonsContainer = document.querySelector('.api-key-buttons');
        container.appendChild(confirmationDiv);

        // Add event listeners for confirm/cancel
        document.getElementById('confirmExportBtn').addEventListener('click', () => {
            this.confirmExportKeys(apiKeys);
            confirmationDiv.remove();
        });

        document.getElementById('cancelExportBtn').addEventListener('click', () => {
            confirmationDiv.remove();
            this.showMessage('Export cancelled', 'info');
        });
    }

    confirmExportKeys(apiKeys) {
        try {
            // Create the text content - one key per line
            const textContent = apiKeys.join('\n');

            // Add metadata comment at the top (optional)
            const metadata = [
                `# Gemini API Keys Export`,
                `# Generated: ${new Date().toLocaleString()}`,
                `# Total Keys: ${apiKeys.length}`,
                `# Keep this file secure!`,
                ''
            ].join('\n');

            const fullContent = metadata + textContent;

            // Create a blob and download link
            const blob = new Blob([fullContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);

            // Create download link
            const a = document.createElement('a');
            a.href = url;
            a.download = 'keys.txt';

            // Trigger download
            document.body.appendChild(a);
            a.click();

            // Cleanup
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);

            this.showMessage(`✅ Successfully exported ${apiKeys.length} API keys`, 'success');

        } catch (error) {
            console.error('Error exporting keys:', error);
            this.showMessage(`❌ Error exporting keys: ${error.message}`, 'error');
        }
    }

    async handleSave(e) {
        e.preventDefault();

        const apiEndPoint = document.getElementById('apiEndPoint').value.trim();
        const autoGenerateDescriptions = document.getElementById('autoGenerateDescriptions').checked;
        const autoSaveProduct = document.getElementById('autoSaveProduct').checked;
        const apiKeys = this.settingsManager.getApiKeys();

        if (apiKeys.length === 0) {
            this.showMessage('❌ Please add at least one API Key', 'error');
            return;
        }

        const settings = {
            apiKeys: apiKeys,
            currentApiKeyIndex: this.settingsManager.getCurrentApiKeyIndex(),
            apiEndPoint: apiEndPoint || 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent',
            autoGenerateDescriptions: autoGenerateDescriptions,
            autoSaveProduct: autoSaveProduct
        };

        try {
            await this.settingsManager.saveToStorage(settings);
            this.showMessage('Settings saved successfully!', 'success');
        } catch (error) {
            this.showMessage(`❌ Error saving settings: ${error.message}`, 'error');
        }
    }

    async handleReset() {
        if (confirm('Are you sure you want to reset to default settings?')) {
            try {
                await this.settingsManager.resetToDefaults();
                this.loadCurrentSettings();
                this.showMessage('✅ Settings reset to defaults', 'success');
            } catch (error) {
                this.showMessage(`❌ Error resetting settings: ${error.message}`, 'error');
            }
        }
    }

    showMessage(message, type = 'info') {
        const messageEl = document.getElementById('statusMessage');
        messageEl.textContent = message;
        messageEl.className = `status-message show ${type}`;

        if (type !== 'error') {
            setTimeout(() => {
                messageEl.classList.remove('show');
            }, 3000);
        }
    }
}

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    new SettingsUI();
    console.log('Settings UI initialized');
});